{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"using-vatican-explorer/","title":"Core API","text":"<p>Some hand-written intro explaining the module.</p>"},{"location":"using-vatican-explorer/#functions","title":"Functions","text":""},{"location":"using-vatican-explorer/#search.search_biblical_citation","title":"search_biblical_citation","text":""},{"location":"using-vatican-explorer/#search.search_biblical_citation-functions","title":"Functions","text":""},{"location":"using-vatican-explorer/#search.search_biblical_citation.default_regex_pattern","title":"default_regex_pattern","text":"<pre><code>default_regex_pattern() -&gt; str\n</code></pre> <p>Function to return the default regex pattern for biblical citations.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The default regex pattern for biblical citations.</p> Source code in <code>src/search/search_biblical_citation.py</code> <pre><code>def default_regex_pattern() -&gt; str:\n\"\"\"Function to return the default regex pattern for biblical citations.\n    Args: \n        None\n    Returns:\n        str: The default regex pattern for biblical citations.\n    \"\"\"\nreturn r'\\b(?:[1-3]\\s+)?[A-Za-z]{2,4}\\s+\\d{1,3}:\\d{1,3}(?:[-.]\\d{1,3})?\\b'\n</code></pre>"},{"location":"using-vatican-explorer/#search.search_biblical_citation.search_biblical_citations","title":"search_biblical_citations","text":"<pre><code>search_biblical_citations(\ntext: str,\ncontext: int = 100,\npattern: str | None = None,\n) -&gt; list[tuple[str, str]]\n</code></pre> <p>Function to search for biblical citations in a given text.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The input text to search for biblical citations.</p> required <code>context</code> <code>int</code> <p>The number of characters to include before and after the citation for context.</p> <code>100</code> <code>pattern</code> <code>str | None</code> <p>The regex pattern to use for searching. If None, a default pattern is used.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[tuple[str, str]]</code> <p>list of tuples: Each tuple contains the found citation and its surrounding context.</p> Source code in <code>src/search/search_biblical_citation.py</code> <pre><code>def search_biblical_citations(text: str, context: int=100, pattern: str | None = None) -&gt; list[tuple[str, str]]:\n\"\"\"Function to search for biblical citations in a given text.\n    Args:\n        text: The input text to search for biblical citations.\n        context: The number of characters to include before and after the citation for context.\n        pattern: The regex pattern to use for searching. If None, a default pattern is used.\n    Returns:\n        list of tuples: Each tuple contains the found citation and its surrounding context.\n    \"\"\"\n# Check that the input text is a string\nif not isinstance(text, str):\nraise ValueError(\"Input text must be a string.\")\n# Check that context is an integer\nif not isinstance(context, int):\nraise ValueError(\"Context must be an integer.\")\n# Check that pattern is a string if provided\nif pattern is not None and not isinstance(pattern, str):\nraise ValueError(\"Pattern must be a string.\")\n# Default regex pattern for biblical citations if none provided\nif pattern is None:\npattern = default_regex_pattern()\n# Search for citations using regex\nmatches = finditer(pattern, text)\n# Initialize results list\nresults = []\n# Iterate over matches\nfor match in matches:\n# Extract citation\ncitation = match.group()\n# Get start and end indices of the match\nstart, end = match.span()\n# Calculate context boundaries\ncontext_start = max(0, start - context)\ncontext_end = min(len(text), end + context)\n# Extract context\nsurrounding_text = text[context_start:context_end]\n# Append citation and context to results\nresults.append((citation, surrounding_text))\n# Return results\nreturn results\n</code></pre>"},{"location":"using-vatican-explorer/#search.search_biblical_citation.search_biblical_citations_db","title":"search_biblical_citations_db","text":"<pre><code>search_biblical_citations_db(\npattern: str | None = None, query: str | None = None\n) -&gt; list[tuple[int, list[tuple[str, str]]]]\n</code></pre> <p>Search database texts for biblical citations matching a regex pattern.</p> <p>This function connects to the database, validates the schema, executes a regex-based SQL query, and extracts biblical citations from each row's text content.</p> <p>Parameters:</p> Name Type Description Default <code>pattern</code> <code>str | None</code> <p>Optional regex pattern used when searching within the <code>text_content</code> column. If not provided, the default biblical citation pattern is used via <code>default_regex_pattern()</code>.</p> <code>None</code> <code>query</code> <code>str | None</code> <p>Optional SQL query override. If not provided, a default query is used that searches the <code>text_content</code> column with a REGEXP clause. The query must contain exactly one positional placeholder (?) for the regex pattern. The query must return all columns from the <code>texts</code> table in the same order as the schema.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[tuple[int, list[tuple[str, str]]]]</code> <p>A list of tuples containing the row ID and the extracted citations.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If required tables, columns, or schema definitions are missing or incorrect.</p> Source code in <code>src/search/search_biblical_citation.py</code> <pre><code>def search_biblical_citations_db(\npattern: str | None = None,\nquery: str | None = None\n) -&gt; list[tuple[int, list[tuple[str, str]]]]:\n\"\"\"Search database texts for biblical citations matching a regex pattern.\n    This function connects to the database, validates the schema, executes a\n    regex-based SQL query, and extracts biblical citations from each row's\n    text content.\n    Args:\n        pattern:\n            Optional regex pattern used when searching within the `text_content`\n            column. If not provided, the default biblical citation pattern is\n            used via `default_regex_pattern()`.\n        query:\n            Optional SQL query override. If not provided, a default query is\n            used that searches the `text_content` column with a REGEXP clause.\n            The query must contain exactly one positional placeholder (?) for\n            the regex pattern. The query must return all columns from the `texts`\n            table in the same order as the schema.\n    Returns:\n        A list of tuples containing the row ID and the extracted citations.\n    Raises:\n        ValueError: If required tables, columns, or schema definitions are\n            missing or incorrect.\n    \"\"\"\nconn = None\ncursor = None\ntry:\n# Connect to the database\nconn, cursor = connect_to_database()\n# Register REGEXP function (SQLite compatibility)\nregister_regexp_function(conn)\n# Validate table\nif not table_exists(cursor, \"texts\"):\nraise ValueError(\"The 'texts' table does not exist in the database.\")\n# Validate schema format\nif not check_texts_table_schema(cursor):\nraise ValueError(\"The 'texts' table schema does not match the expected format.\")\n# Default SQL query\ndefault_query = \"\"\"SELECT * FROM texts WHERE text_content REGEXP ?\n        \"\"\"\n# Use default query if none provided\nsql = query or default_query\n# Use default regex pattern if none provided\nif pattern is None:\npattern = default_regex_pattern()\n# Fetch rows matching the regex pattern\nrows = fetch_rows_by_regexp(cursor, sql, pattern)\nresults = []\n# Extract citations from each row's text content\nfor row in rows:\nrow_id = row[0]\ntext_content = row[9] \nif not isinstance(text_content, str):\ncitations = []\nelse:\ncitations = search_biblical_citations(text_content, pattern=pattern)\nresults.append((row_id, citations))\nreturn results\nfinally:\nif conn is not None and hasattr(conn, \"close\"):\nconn.close()\n</code></pre>"},{"location":"using-vatican-explorer/#more-functions","title":"More functions","text":""},{"location":"using-vatican-explorer/#vatican_scraper.argparser","title":"argparser","text":""},{"location":"using-vatican-explorer/#vatican_scraper.argparser-functions","title":"Functions","text":""},{"location":"using-vatican-explorer/#vatican_scraper.argparser.get_scraper_args","title":"get_scraper_args","text":"<pre><code>get_scraper_args() -&gt; Tuple[ArgumentParser, Namespace]\n</code></pre> <p>Parse command-line arguments for the Vatican scraper. Returns:     tuple: (ArgumentParser, Namespace) where Namespace contains parsed arguments. Purpose:     - Parses arguments for scraping Vatican speeches, including pope(s), years, section, language, etc.     - Ensures that the 'pope' argument is always a non-empty list; if not provided, defaults to ['Francis'].     - Handles both --pope (repeatable) and --popes (comma-separated) arguments.</p> Source code in <code>src/vatican_scraper/argparser.py</code> <pre><code>def get_scraper_args() -&gt; Tuple[argparse.ArgumentParser, argparse.Namespace]:\n\"\"\"\n    Parse command-line arguments for the Vatican scraper.\n    Returns:\n        tuple: (ArgumentParser, Namespace) where Namespace contains parsed arguments.\n    Purpose:\n        - Parses arguments for scraping Vatican speeches, including pope(s), years, section, language, etc.\n        - Ensures that the 'pope' argument is always a non-empty list; if not provided, defaults to ['Francis'].\n        - Handles both --pope (repeatable) and --popes (comma-separated) arguments.\n    \"\"\"\np = scraper_parser()\nargs = p.parse_args()\npopes = _gather_popes(args)\nargs.popes = popes\n# only return the first pope here if a list is given\nargs.pope = popes[0]\nreturn (p, args)\n</code></pre>"},{"location":"using-vatican-explorer/#vatican_scraper.step05_add_to_database","title":"step05_add_to_database","text":""},{"location":"using-vatican-explorer/#vatican_scraper.step05_add_to_database-functions","title":"Functions","text":""},{"location":"using-vatican-explorer/#vatican_scraper.step05_add_to_database.ensure_db_and_table","title":"ensure_db_and_table","text":"<pre><code>ensure_db_and_table(\ndb_path: Path, table_schema: str = DEFAULT_TABLE_SCHEMA\n) -&gt; None\n</code></pre> <p>Create the sqlite database if it doesn't exist.</p> <p>Parameters:</p> Name Type Description Default <code>db_path</code> <code>Path</code> <p>path to sqlite file (creates file if doesn't exist)</p> required <code>table_schema</code> <code>str</code> <p>SQL schema</p> <code>DEFAULT_TABLE_SCHEMA</code> <p>Does not return content</p> Source code in <code>src/vatican_scraper/step05_add_to_database.py</code> <pre><code>def ensure_db_and_table(db_path: Path, table_schema: str = DEFAULT_TABLE_SCHEMA) -&gt; None:\n\"\"\"\n    Create the sqlite database if it doesn't exist.\n    Args:\n        db_path: path to sqlite file (creates file if doesn't exist)\n        table_schema: SQL schema\n    Does not return content\n    \"\"\"\nconn = sqlite3.connect(db_path)\ntry:\ncur = conn.cursor()\ncur.executescript(table_schema)\nconn.commit()\nfinally:\nconn.close()\n</code></pre>"},{"location":"using-vatican-explorer/#vatican_scraper.step05_add_to_database.add_content_to_db","title":"add_content_to_db","text":"<pre><code>add_content_to_db(\ndb_path: Path,\nrecord: Dict[str, Optional[str]],\nreplace: bool = False,\n) -&gt; Tuple[int, int]\n</code></pre> <p>Add a text record (dict) to the SQLite DB. Creates DB if needed. Update the popes database if needed.</p> <p>Parameters:</p> Name Type Description Default <code>db_path</code> <code>Path</code> <p>path to sqlite database file (creates file if doesn't exist)</p> required <code>record</code> <code>Dict[str, Optional[str]]</code> <p>dictionary with keys like 'pope','name','date','text', etc</p> required <code>replace</code> <code>bool</code> <p>if True, will REPLACE an existing row with the same (pope,name,date).      If False, will IGNORE duplicates (default).</p> <code>False</code> <p>Returns:</p> Type Description <code>Tuple[int, int]</code> <p>row id of inserted/updated (text, pope), or 0 if ignored.</p> Source code in <code>src/vatican_scraper/step05_add_to_database.py</code> <pre><code>def add_content_to_db(db_path: Path, record: Dict[str, Optional[str]], replace: bool = False) -&gt; Tuple[int, int]:\n\"\"\"\n    Add a text record (dict) to the SQLite DB. Creates DB if needed.\n    Update the popes database if needed.\n    Args:\n        db_path: path to sqlite database file (creates file if doesn't exist)\n        record: dictionary with keys like 'pope','name','date','text', etc\n        replace: if True, will REPLACE an existing row with the same (pope,name,date).\n                 If False, will IGNORE duplicates (default).\n    Returns:\n        row id of inserted/updated (text, pope), or 0 if ignored.\n    \"\"\"\nensure_db_and_table(db_path)\n# canonicalize keys and provide defaults\npope_name = record.get(\"pope\")\npope_slug = record.get(\"pope_slug\")\npope_number = record.get(\"pope_number\")\nsecular_name = record.get(\"secular_name\")\nplace_of_birth = record.get(\"place_of_birth\")\nsection = record.get(\"section\")\nyear = record.get(\"year\")\npontificate_begin = record.get(\"pontificate_begin\")\npontificate_end = record.get(\"pontificate_end\")\ndate = record.get(\"date\")\nlocation = record.get(\"location\")\ntitle = record.get(\"title\")\nlanguage = record.get(\"language\")\ntext = record.get(\"text\")\nurl = record.get(\"url\")\nentry_creation_date = datetime.now(timezone.utc).isoformat()  # store UTC timestamp\nconn = sqlite3.connect(db_path)\nconn.execute(\"PRAGMA foreign_keys = ON;\")\ntry:\ncur = conn.cursor()\n# IGNORE will skip insertion if UNIQUE constraint conflict occurs\nsql_starter = \"INSERT OR IGNORE INTO\"\nif replace:\n# REPLACE will delete the existing row with conflicting unique key and insert a new one\nsql_starter = \"INSERT OR REPLACE INTO\"\n# update pope database\nsql_pope = sql_starter + \"\"\"\n            popes\n                (pope_name, pope_slug, pope_number, secular_name, place_of_birth, pontificate_begin, pontificate_end, entry_creation_date)\n            VALUES (?, ?, ?, ?, ?, ?, ?, ?)\n        \"\"\"\ncur.execute(sql_pope, (pope_name, pope_slug, pope_number, secular_name, place_of_birth, pontificate_begin, pontificate_end, entry_creation_date))\nconn.commit()\n_pope_id = cur.lastrowid or 0\n# retrieve the pope_id (whether newly inserted or existing)\ncur.execute(\"SELECT _pope_id FROM popes WHERE pope_name = ? AND pope_number = ?\", (pope_name, pope_number))\nrow = cur.fetchone()\nif row is None:\nraise ValueError(f\"Pope {pope_name} (#{pope_number}) not found in database.\")\npope_id = row[0]\n# update texts database\nsql_text = sql_starter + \"\"\"\n            texts\n                (pope_id, section, year, date, location, title, language, url, text_content, entry_creation_date)\n            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\n        \"\"\"\ncur.execute(sql_text, (pope_id, section, year, date, location, title, language, url, text, entry_creation_date))\nconn.commit()\n_text_id = cur.lastrowid or 0\n# If row was ignored, lastrowid will be 0; if replaced/inserted, lastrowid is the row id.\nreturn _text_id, _pope_id\nfinally:\nconn.close()\n</code></pre>"},{"location":"using-vatican-explorer/#vatican_scraper.step05_add_to_database.main","title":"main","text":"<pre><code>main() -&gt; None\n</code></pre> <p>Example of how to add a single text to the database.  This is not intended to be run on its own. Instead, the code above should be run as part of the overall scraping pipeline, as in step06_run_scraping_pipeline.py.</p> Source code in <code>src/vatican_scraper/step05_add_to_database.py</code> <pre><code>def main() -&gt; None:\n\"\"\"\n    Example of how to add a single text to the database.  This is not intended to be run on its own.\n    Instead, the code above should be run as part of the overall scraping pipeline, as in step06_run_scraping_pipeline.py.\n    \"\"\"\np, args = get_scraper_args()\n_, rows = fetch_speeches_to_feather(\npope=args.pope,\nyears_spec=args.years,\nlang=args.lang,\nsection=args.section,\nout=args.out,\ndebug_loc=args.debug_loc,\nmax_n_speeches=1\n)\nfor row in rows:\nprint(row[\"url\"])\n_text_id, _pope_id = add_content_to_db(_DB_PATH, row)\nif _text_id:\nprint(\"Inserted text into database with id:\", _text_id)\nelse:\nprint(\"Text record already exists (ignored).\")\nif _pope_id:\nprint(\"Inserted pope into database with id:\", _pope_id)\nelse:\nprint(\"Pope record already exists (ignored).\")\n</code></pre>"}]}